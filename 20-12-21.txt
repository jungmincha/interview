1.제네릭 클래스의 타입 인자 제한하는 방법과 효과는?

class Box <T>{
}

===============
class Box<T extends Number>
이런 식으로 작성해 준다.

T로 전달되는 인자는 Number 클래스를 상속한다.

Number 클래스 내의 함수를 사용 가능하게 된다.

타입을 제한함으로써 잘못된 타입을 지정하면 타입 에러를 컴파일 타임에 검출해서 컴파일시 에러를 방지 할 수 있다.


인스턴스 생성 시 타입 인자로 Number 또는 이를 상속하는 클래스만 올 수 있음
ex) class Box<T extends Number> {...} => 와 같이 Number 클래스를 상속하면 기본형으로 타입을 제한-String, Apple과 같은 타입은 들어오지 못함-

2.아래와 같이 출력값이 나오도록 프로그래밍 하시오.

class DDBoxDemo {
    public static void main(String[] args) {
        DBox<String, Integer> box1 = new DBox<>();
        box1.set("Apple", 25);

        DBox<String, Integer> box2 = new DBox<>();
        box2.set("Orange", 33);
        
        DDBox<DBox<String, Integer>, DBox<String, Integer>> ddbox = new DDBox<>();
        ddbox.set(box1, box2);

        System.out.println(ddbox);
    }
}


=======================================================================클래스=======================================================================================


class DBox10<L, R> {
	
	private L left;
	private R right;

	public void set(L o, R r) {

		left = o;
		right = r;

	}

	public String toString() {
		return left + " & " + right;
	}

}

class DDBox<L,R>{
	
	private L left;
	private R right;
	
	public void set(L o, R r) {

		left = o;
		right = r;

	}
	
	public String toString() {
		return left + "\n " + right;
				

	}
	
}


==================
Apple & 25
Orange & 33







3.아래와 같이 출력값이 나오도록 프로그래밍 하시오.

    public static void main(String[] args) {
        Box<Integer> box1 = new Box<>();
        box1.set(99);

        Box<Integer> box2 = new Box<>();
        box2.set(55);

        System.out.println(box1.get() + " & " + box2.get());
        swapBox(box1, box2);
        System.out.println(box1.get() + " & " + box2.get());
    }
==========
99 & 55
55 & 99

:


class ArrayExercise<L> {

	private L ob;

	public void set(L o) {

		ob = o;
	}

	public L get() {
		return ob;

	}

	public static <L> void swapBox(Box<L> box1, Box<L> box2) {

		Box<L> tmp = new Box<L>();
		tmp.set(box1.get());
		box1.set(box2.get());
		box2.set(tmp.get());

	}

	public static void main(String[] args) {

		Box<Integer> box1 = new Box<>();
		box1.set(99);

		Box<Integer> box2 = new Box<>();

		System.out.println(box1.get() + " & " + box2.get());
		swapBox(box1, box2);
		System.out.println(box1.get() + " & " + box2.get());

	}

}


4.지네릭 메소드에 대하여 설명하시오.

: 클래스 전부가 아닌 메소드 하나에 대해서만 제네릭을 정의하는 것이다. 지역성을 가진다.



5.와일드 카드와 상한 제한, 하한 제한에 대하여 설명하시오.
: 와일드 카드는 제네릭과 기능적으로 거의 같다

6.아래가 에러가 나는 이유를 설명하시오.
public static void inBox(Box<? super Toy> box, Toy n) {
   box.set(n);   // 넣는 것! OK!
   Toy myToy = box.get();   // 꺼내는 것! Error!
}

:폴리몰피즘 때문이다.

7.아래와 같이 메소드 오버로딩이 되지 않는 이유는?
// 다음 두 메소드는 오버로딩 인정 안됨.
   public static void outBox(Box<? extends Toy> box) {...}
   public static void outBox(Box<? extends Robot> box) {...}
   
   폴리몰피즘 때문이다. 

:

8.아래의 결과가 나오도록 프로그래밍을 완성하시오.
 public static void main(String[] args) {
        Box<Integer> box1 = new Box<>();
        box1.set(24);

        Box<String> box2 = new Box<>();
        box2.set("Poly");

        if(compBox(box1, 25))
            System.out.println("상자 안에 25 저장");

        if(compBox(box2, "Moly"))
            System.out.println("상자 안에 Moly 저장");
        
        System.out.println(box1.get());
        System.out.println(box2.get());
    }

=======
24
Poly

:


class GenericExercise<T> {

	private T ob;

	public void set(T o) {

		ob = o;

	}

	public T get() {
		return ob;
	}

	public static <T> boolean compBox(Box<T> a, T b) {
		T check = a.get();
		return check.equals(b);

	}

	public static void main(String[] args) {

		Box<Integer> box1 = new Box<>();
		box1.set(24);

		Box<String> box2 = new Box<>();
		box2.set("Poly");

		if (compBox(box1, 25))
			System.out.println("상자 안에 25 저장");

		if (compBox(box2, "Moly"))
			System.out.println("상자 안에 Moly 저장");

		System.out.println(box1.get());
		System.out.println(box2.get());

	}

}







9.콜렉션 프레임워크란?
:
자료 구조 및 알고리즘을 구현해놓은 클래스가 한데 모인 일종의 라이브러리다. 제네릭 기반으로 구현되어있다.
구현하는 인터페이스의 특성에 따라 사용방법과 특성이 정해진다.

collection<E> - set<E> - List<E> - Queue<E>   || Map<K , V>

List<E> 인터페이스를 구현하는 대표적인 컬렉션 클래스 둘이다.

ArrayList<E> 배열 기반 자료 구조, 배열을 이용하여 자료를 저장한다. 저장된 인스턴스의 참조가 빠르다. 저장공간을 늘리는 과정에서 시간이 비교적 많이 소모된다.

LinkedList<E> 리스트 기반 자료 구조, 리스트를 구성하여 자료를 저장한다. 참조과정이 배열보다 복잡해서 느릴 수 있다. 저장공간을 늘이는 과정이 단순하다. 저장된 인스턴스의 삭제 과정이 단순하다.


인스턴스의 저장 순서 유지 , 동일 인스턴스의 중복 저장을 허용한다.
